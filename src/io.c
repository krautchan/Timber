/* 
 * io.c -- I/O routines
 * 
 * Copyright (C) 2012  Martin Wolters.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to 
 * the Free Software Foundation, Inc.
 * 51 Franklin Street, Fifth Floor
 * Boston, MA  02110-1301, USA
 * 
 */

#include <Windows.h>
#include <stdio.h>

#include "..\include\sha256.h"
#include "..\include\tommath.h"

unsigned char *xorchar(unsigned char *a, unsigned char *b, size_t size) {
	size_t i;
	unsigned char *out = malloc(size);

	for(i = 0; i < size; i++)
		out[i] = a[i] ^ b[i];

	return out;
}

int fillbuffer(unsigned char *dst, int len, void *dat) {
	HCRYPTPROV provider;
	
	CryptAcquireContext(&provider, NULL, NULL, PROV_RSA_FULL, 0);
	CryptGenRandom(provider, len, dst);
	CryptReleaseContext(provider, 0);
	return len;
}

void mp_print(mp_int *i) {
	char *c;
	int size;
	
	mp_radix_size(i, 16, &size);
	if((c = malloc(size)) == NULL)
		return;
	
	mp_toradix(i, c, 16);
	printf("%s\n", c);
	free(c);
}

hash_t mp_hash(mp_int *i) {
	int size;
	unsigned char *c;
	hash_t out;

	size = mp_unsigned_bin_size(i);
	c = malloc(size);
	mp_to_unsigned_bin(i, c);
	out = sha256(c, size);
	free(c);

	return out;
}

int gentable(char *id, mp_int *in, FILE *fp) {
	int size, i;
	unsigned char *c;

	fprintf(fp, "char %s[] = {\n\t", id);

	size = mp_unsigned_bin_size(in);
	if((c = malloc(size)) == NULL)
		return 0;

	mp_to_unsigned_bin(in, c);	

	for(i = 0; i < size; i++) {
		fprintf(fp, "0x%02x", c[i]);
		if(i < size - 1)
			fprintf(fp, ",");
		if(!((i + 1) % 16) && (i != (size - 1)))
			fprintf(fp, "\n\t");
		else
			fprintf(fp, " ");
	}

	fputs("\n};\n\n", fp);

	return 1;
}

int gensource(mp_int *p, mp_int *g, mp_int *priv, mp_int *pub, mp_int *auth, char *filename) {
	FILE *fp;
	hash_t hash_auth;

	if((fp = fopen(filename, "w")) == NULL)
		return 0;

	fprintf(fp, "/* THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY KEYGEN.EXE */\n\n");
	fprintf(fp, "#ifndef DH_KEY\n");
	fprintf(fp, "#define DH_KEY\n\n");

	gentable("dh_key_p", p, fp);
	gentable("dh_key_g", g, fp);
	gentable("dh_key_priv", priv, fp);
	gentable("dh_key_pub", pub, fp);

	hash_auth = mp_hash(auth);
	
	fprintf(fp, "unsigned int dh_key_authed[] = {\n\t");
	fprintf(fp, "0x%08x, 0x%08x, 0x%08x, 0x%08x, ", 
			hash_auth.h0, hash_auth.h1, hash_auth.h2, hash_auth.h3);
	fprintf(fp, "0x%08x, 0x%08x, 0x%08x, 0x%08x\n};\n\n", 
			hash_auth.h4, hash_auth.h5, hash_auth.h6, hash_auth.h7);		
	
	fprintf(fp, "#endif\n");

	fclose(fp);

	return 1;
}